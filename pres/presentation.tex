\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usetheme{Warsaw}

\title{Embedded Systems - Bachelor Project}
\author{Moritz Herzog, Philipp Lersch}
\date{\today}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, chains, calc}


\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}
\maketitle


\section{OpenCL}
\begin{frame}
    \frametitle{OpenCL Structure}
    \begin{columns}
        \column{.6\textwidth}
        \includegraphics[width=\textwidth]{res/HardwareSoftwareLayer.jpg}
        \column{.4\textwidth}
        \begin{itemize}
            \item OpenCL draws clear line between hardware and software
            \item Kernels can be scheduled on CPU, GPU and other architecures
        \end{itemize}
    \end{columns}
\end{frame}
\subsection{Hardware Model}
\begin{frame}
    \frametitle{Hardware Model - Generel}
    OpenCL Propertys:
    \begin{itemize}
     \item Diffrent models for CPU and GPU
     \item In General:
     \begin{itemize}
      \item a compute device has a separade memory
      \item a compute unit can have multible processing elements 
     \end{itemize}
     \item One CPU-Based ``Host'' controlls multible ``Computedevices''
     \item ``Computedevice'' is every OpenCL complient connected GPU, CPU and FPGA and even more. 
     \item ``Processing Elements'' all execute OpenCL ``Kernels''
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Hardware Model - Generel}
    \includegraphics[width=\textwidth]{res/KhronosPlatformModel.png}
\end{frame}

\begin{frame}
    \frametitle{Hardware Model - Memory}
        \includegraphics[width=.8\textwidth]{res/OpenCLMemoryStructure.jpg}
        
\end{frame}
\begin{frame}
    \frametitle{Hardware Model - Memory}
        \begin{itemize}
            \item Private Memory
            \begin{itemize}
             \item Private for every Workitem
            \end{itemize}
            \item Local Memory
            \begin{itemize}
             \item Shared within the Workgroup
             \item Synchronization within the Workgroup
            \end{itemize}
            \item Global/Constant Memory
            \begin{itemize}
             \item Visible for all Workgoups within the device
            \end{itemize}
            \item Host Memory
            \begin{itemize}
             \item Local DRAM
            \end{itemize}
            \item Memorymanagement is Explicit.
            \item Communication and Synchronization (only possible within a workgroup) is done over the Memory.
        \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Hardware Model - CPU}
    Architecure:
    \begin{itemize}
        \item ``Processing Units'' are the ``Treads/Cores''
        \item If not sepreadly connected, CPU has a shared memory with the system and other programs that use the CPU
    \end{itemize}
    Benefits
    \begin{itemize}
        \item Benefits from idependant instruction in a kernel.
    \end{itemize}

\end{frame}
\begin{frame}
    \frametitle{Hardware Model - GPU}
    Architecure:
    \begin{itemize}
     \item ``Processing Unit'' are the execution and arithmetic processing Units
     \item Specific Definition of ``Processing Units'' depends on the Hardware Vendor and generation
     \item A ``Processing Unit'' has mutlible cores
    \end{itemize}
    Benefits:
    \begin{itemize}
     \item GPU-Architecure benefits from small, sequential and highly parallel Workloads.
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Hardware Model - GPU}
    \begin{columns}
        \column[T]{.4\textwidth}
        \includegraphics[width=\textwidth]{res/ATIComputeDevice.png}
        \column[T]{.6\textwidth}
        Example of AMD GPU ``Processing Units''
    \end{columns}
\end{frame}
\begin{frame}{Example Raspberry Pi 3B+}
    \includegraphics[height=.8\textheight]{res/RaspberryPiData.PNG}
\end{frame}
\subsection{Software Model}
\begin{frame}
    \frametitle{Software Model}
\end{frame}

\section{Kernels}
\subsection{Overview}
\begin{frame} %%Eine Folie
  \frametitle{List of Kernels} %%Folientitel
  Already there:
  \begin{itemize}
   \item Battery
   \item Speed
   \item Acceleration
   \begin{itemize}
    \item X-Achsis
    \item Y-Achsis
    \item Tangential
   \end{itemize}
   \item Tempreture
  \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{List of Kernels}
    Added Kernels:
    \begin{itemize}
     \item Accident Detection
     \item Tractioncontrol
     \item Range
     \item Turningradius
    \end{itemize}
\end{frame}

\subsection{Accident Detection}
\begin{frame}
    \frametitle{Accident Detection}
    By testing for accelerationspikes or accelerationvalues, we are able to detect accidents and unexpected movement.\\
    \begin{itemize}
     \item Check for values above or below given thresholds which should be unachieveable under normal circumstances.\\
     $\Rightarrow$ If found, we crashed.
     \pause
     \item In addition we can look for spikes in the last n-datapoints of the acceration and determine light crashes.\\
     $\Rightarrow$ If found, we crashed.
     \pause
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Accident Detection}
    Algorithm
    \begin{enumerate}
        \item Get n last accelerationvalues
        \item Calculate: 
        \begin{itemize}
            \item $crossed = accelMin_{x,y} > accel_{x,y} \parallel accel_{x,y} > accelMax_{x,y}$
            \item spiked if $m$ datapoints signal a harsh acceleration possibly followed by a harsh deceleration in a given direction.
        \end{itemize}
    \end{enumerate}
\end{frame}

\subsection{Anti Blocking System}
\begin{frame}
    \frametitle{Anti Blocking System}
    By comparing the fronts average and back wheels speeds we can determine if the rear wheels are turning to slow or are locking up. 
    \begin{itemize}
     \item Check if the rear wheels are spinning much slower (threshold is around 40\%) than the front wheels.\\
     $\Rightarrow$ If this is true for one or both wheels we are breaking to hard.
     $\Rightarrow$ Signal traction loss.
     \pause
     \item We could also try to regain traction by speeding up the motor. 
     $\Rightarrow$ Hard to implement with given systems and no finer wheel control. \\
     \pause
    \end{itemize}
\end{frame}

\subsection{Drive Slip Control}
\begin{frame}
    \frametitle{Drive Slip Control}
    By comparing the fronts average and back wheels speeds we can determine if the rear wheels are turning to fast. 
    \begin{itemize}
     \item Check if the rear wheels are spinning much faster (threshold is around 40\%) than the front wheels.\\
     $\Rightarrow$ If this is true for one or both wheels we are accelerating to hard.
     $\Rightarrow$ Signal traction loss.
     \pause
     \item We could also try to regain traction by slowing down the motor.
     $\Rightarrow$ Hard to implement with given systems and no finer wheel control. \\
     \pause
    \end{itemize}
\end{frame}

\subsection{Tractioncontrol}
\begin{frame}
    \frametitle{Tractioncontrol}
    By comparing the fronts average and back wheels speeds we can determine if the rear wheels have lost to much traction.
    \begin{itemize}
    \item Check if the rear wheels are spinning outside of their thresholds.\\
        \begin{enumerate}
        \item If one or both wheels are to slow we are breaking to hard.\\
        $\Rightarrow$ Signal traction loss.\\
        \item If one or both wheels are to fast we are accelerating to hard.\\
        $\Rightarrow$ Signal traction loss.
        \end{enumerate}
     \pause
     \item Without the needed capabilities we are only cabalbe to signal traction loss reliable.
     \pause
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Tractioncontrol}
    Algorithm
    \begin{enumerate}
        \item Get current wheel speeds
        \item Calculate: 
        \begin{itemize}
            \item $averageFrontWheelSpeed = \frac{leftWheelSpeed + rightWheelSpeed}{2}$
            \item $slipping = (aFWS-T) > bWS \parallel bWS > (aFWS+T)$
        \end{itemize}
    \end{enumerate}
\end{frame}

\subsection{Range}
\begin{frame}
    \frametitle{Range}
    Requirements:
    \begin{itemize}
        \item Knowlegde of the maximum Battery Charge in Wh
        \item Minimum charge voltage
        \item Engine propertys (load to watt usage)
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Range}
    Algorithm
    \begin{enumerate}
     \item Get current battery voltage
     \item Calculate current charge in Wh
     \item Calculate on engine load, engine properties and current speed the currently consumed wattage
     \item Calculate the remaining Range with these Formulars.
     \begin{itemize}
        \item $remainingTime=\frac{Charge}{Current Wattage}\cdot3600$
        \item $remainingRange=speed\cdot remainingTime$
     \end{itemize}
    \end{enumerate}
\end{frame}

\subsection{Turningradius}
\begin{frame}
    \frametitle{Turningradius}
    Requirements:
    \begin{itemize}
     \item wheel Velocity of every wheel separated ($\Sigma_{RR}$, $\Sigma_{RL}$, $\Sigma_{FR}$, $\Sigma_{FL}$)
     \item Knowlegde of the width of the axle (Distance of the two wheels on one axle) ($D$)
    \end{itemize}
    Algorithm:
    \begin{enumerate}
     \item Calculate the following Formular
     \begin{itemize}
        \item $r=\frac{D}{2}*\frac{\Sigma_{RR}+\Sigma_{RL}}{\Sigma_{RR}-\Sigma_{RL}}$
        \item Same can be done for the front axle to calculate slippage
     \end{itemize}
     \item if $r<0$ then $r=-r$
    \end{enumerate}
\end{frame}

\end{document}
